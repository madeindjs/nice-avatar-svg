Recently, I was working [on a side project](https://the-killer.online/) and I found at a small lib to generate avatars called [react-nice-avatar](https://github.com/dapi-labs/react-nice-avatar). This library is really awesome because it allows me to generate avatar for my users like this:

![Avatar generated by react-nice-avatar](./preview.png)

But then, I wanted to move away from React and maybe doing a version of the same application using another frontend framework (just for the sake of testing different way).

The generated Avatar logic is strateforward: it's just conditional component to display or not:

```jsx
// https://github.com/dapi-labs/react-nice-avatar/blob/main/src/hair/index.tsx
export default function hair(props: { style: string, color: string, colorRandom: boolean }): SVGElement {
  const { style, color, colorRandom } = props;
  switch (style) {
    case "thick":
      return <Thick color={color} colorRandom={colorRandom} />;
    case "mohawk":
      return <Mohawk color={color} colorRandom={colorRandom} />;
    case "womanLong":
      return <WomanLong color={color} />;
    case "womanShort":
      return <WomanShort color={color} />;
    case "normal":
    default:
      return <Normal color={color} />;
  }
}
```

So, it could be easily ported to any JSX rendering engine ([Solid.js](https://github.com/solidjs/solid), [Preact](https://preactjs.com/), [Hono](https://hono.dev/guides/jsx), etc..), no?

I wanted to give a try!

## Why?

> Why don't simply use any framework and wrap it into a [Web Component][web-components] (like [React to Web Component](https://github.com/bitovi/react-to-web-component))?

It means shipping the React engine in the web component and that has a a big cost: React is big, and maybe the developer already use an another framework which can reuse the same engine

> Why don't you simply use a Javascript template library like [EJS](https://github.com/mde/ejs) or [nunjucks](https://github.com/mozilla/nunjucks/)?

Yes, it could have been a solution but templates languages are easier to maintain in separated files which make it not compatible on frontend. Templates can be defined in the Javascript code but it become a nightmare to maintain it.

> Why do you do this, Isn't it too much for a side project? Rewriting your project does not provide value to your APP.

Yes, it's true. But it's mainly to experiment Monorepo & other libraries.

## Objectives

1. provide it to as many as possible JSX engines ([Solid.js](https://github.com/solidjs/solid), [Preact](https://preactjs.com/), [React](https://github.com/facebook/react/), and others)
2. export it as as [Web Component][web-components]
3. export a `render` function to use it in any backend framework without frontend library

## Let's code

So we'll start a new monorepo using [NPM workspace](https://docs.npmjs.com/cli/v7/using-npm/workspaces) and export a few libraries:

```json
// package.json
{
  "name": "@nice-avatar-svg/monorepo",
  "private": true,
  "workspaces": ["element", "preact", "react", "solid", "render", "shared"]
}
```

Let's have a look at our workspaces.

### `share` package

This library will contains our JSX components. JSX needs to be bundled by a library, so we can't use it. But we'll export them as is.

```
shared
├── components
│   ├── Body.jsx
│   ├── EarAttached.jsx
│   ├── EarDetached.jsx
│   ├── ...
│   ├── EyebrowsDown.jsx
│   ├── ShirtCollared.jsx
│   ├── ShirtCrew.jsx
│   └── ShirtOpen.jsx
├── constants.mjs
├── model.mjs
├── package.json
└── README.md
```

I just put all my components and some type definitions and that's it.

The `package.json` is straitfoward:

```json
// shared/package.json
{
  "name": "@nice-avatar-svg/shared",
  "type": "module",
  "types": "model.mjs",
  "version": "0.0.1",
  "private": true,
  "license": "ISC"
}
```

### `preact` library

Ok, now we have our component, the goal is to use it and export it for [Preact][preact].

We just have to bootstrap a Preact project using [Vite][vite]:

```sh
npm create vite@latest
✔ Project name: … @nice-avatar-svg/preact
✔ Select a framework: › Preact
✔ Select a variant: › JavaScript
```

We simply create a new component named `NiceAvatar` and import, assemble and export the component:

```jsx
// preact/NiceAvatar.jsx
// ...
const EarAttached = lazy(() => import("@nice-avatar-svg/shared/components/EarAttached"));
const EarDetached = lazy(() => import("@nice-avatar-svg/shared/components/EarDetached"));
const EarRingHoop = lazy(() => import("@nice-avatar-svg/shared/components/EarRingHoop"));
// ...

/**
 * @typedef {import('@nice-avatar-svg/shared/model.mjs').AvatarConfiguration} Props
 * @param {Props} props
 */
export default function NiceAvatar({
  bgColor = COLORS.Azure,
  earSize = "small",
  skinColor = COLORS.Apricot,
  shape = "circle",
  // ...
}) {
  return (
    <Layout shape={shape} bgColor={bgColor}>
      <Body skinColor={skinColor} />
      <Suspense fallback={<LoadingNode />}>
        <Ear earSize={earSize} skinColor={skinColor} />
      </Suspense>
      {/* ... */}
    </Layout>
  );
}

const LoadingNode = () => <></>;

/** @param {Pick<Props, 'earSize' | 'skinColor'>} param0 */
function Ear({ earSize, skinColor }) {
  switch (earSize) {
    case "big":
      return <EarDetached skinColor={skinColor} />;
    case "small":
      return <EarAttached skinColor={skinColor} />;
    default:
      return <></>;
  }
}
// ...
```

Now we just have to enable [Vite][vite] to expose ou component in `vite.config.js`

```js
// preact/vite.config.js
// ...
export default defineConfig({
  // ...
  build: {
    target: "esnext",
    lib: {
      name: "@nice-avatar-svg/preact",
      entry: fileURLToPath(new URL("./NiceAvatar.jsx", import.meta.url)),
    },
  },
});
```

And we specify in `package.json` to export this component and import it `@nice-avatar-svg/shared`

```json
// preact/package.json
{
  "name": "@nice-avatar-svg/preact",
  // ..
  "module": "./dist/preact.js",
  "main": "dist/preact.umd.cjs",
  "exports": ["./NiceAvatar.jsx"],
  "devDependencies": {
    "@preact/preset-vite": "^2.8.2",
    "vite": "^5.0.11"
  },
  "peerDependencies": {
    "preact": ">=10.0.0"
  },
  "dependencies": {
    "@nice-avatar-svg/shared": "*"
  }
}
```

Then check it works building the project using `npm run build`.

#### Testing it

Just to makes sure it works properly, we'll bootstrap and another project and test it quickly.

First, we initialize the linking process

```sh
npm link
```

Create a new Vite project with Preact

```sh
cd /tmp && npm create vite@latest
✔ Project name: … vite-project
✔ Select a framework: › Preact
✔ Select a variant: › JavaScript
```

Then we link our package:

```sh
npm link @nice-avatar-svg/preact
```

To link a local dependency, you simply need to run `npm link` in `preact/` folder and then update the `src/app.jsx` file

```jsx
import NiceAvatar from "@nice-avatar-svg/preact";
import { Suspense } from "preact/compat";

export function App() {
  return (
    <Suspense fallback={"Loading..."}>
      <NiceAvatar />
    </Suspense>
  );
}
```

The run `npm run dev` and voilà! As you can see, everything work properly. The good part is the build

```sh
npm run build

> vite-project@0.0.0 build
> vite build

vite v5.2.11 building for production...
✓ 48 modules transformed.
...
dist/assets/MouthSmile-DHK0m80w-DOpgu1La.js              0.23 kB │ gzip:  0.20 kB
dist/assets/NosePointed-DzhHrocg-CWPme9UT.js             0.25 kB │ gzip:  0.21 kB
dist/assets/NoseCurve-CdVIF_wC-Bd18D9Fz.js               0.26 kB │ gzip:  0.22 kB
...
dist/assets/index-DcyXC5km.js                           47.15 kB │ gzip: 13.08 kB
```

1. every components are lazy loaded and split into smaller chunks
2. Preact is bundled once, we reuse the same engine

### `react` & `solid` libraries

As you might guess, this is the exact same steps

1. create a vite project
2. introduce the component (which is almost a copy/paste of the `NiceAvatar.jsx` component)
3. export it through `vite.config.js` & `package.json`

### `element` library

Fairly easy too, we just create a new package which import two libs: the preact version and [preact-custom-element](https://github.com/preactjs/preact-custom-element)

```json
// element/package.json
{
  "name": "@nice-avatar-svg/element",
  // ...
  "dependencies": {
    "@nice-avatar-svg/preact": "*",
    "preact-custom-element": "^4.3.0"
  }
}
```

Then we just have to expose our

```js
import register from "preact-custom-element";
import NiceAvatar from "../preact/NiceAvatar";

register(
  NiceAvatar,
  "nice-avatar",
  [
    /* props */
  ],
  { shadow: false }
);
```

#### Testing it

Again, you can reuse our `/tmp/vite-project` to test it quickly.

Simply import the module, and instantiate the custom element.

```html
<!DOCTYPE html>
<html lang="en">
  <!-- ... -->
  <body>
    <!-- ... -->
    <nice-avatar />
    <script type="module" src="node_modules/@nice-avatar-svg/element"></script>
  </body>
</html>
```

### `render` library

Last step, our render function! This one might be useful for rendering it on server side.

We'll again reuse the `preact/` version and use [preact-render-to-string](https://www.npmjs.com/package/preact-render-to-string) library.

```json
// render/package.json
{
  "name": "@nice-avatar-svg/render",
  // ...
  "dependencies": {
    "@nice-avatar-svg/preact": "*",
    "preact-render-to-string": "^6.4.2"
  },
  "devDependencies": {
    "@nice-avatar-svg/shared": "*"
  }
}
```

And we simply export a single function

```js
// render/index.mjs
import NiceAvatar from "@nice-avatar-svg/preact";
import { renderToStringAsync } from "preact-render-to-string";

/**
 * @param {import('@nice-avatar-svg/shared/model.mjs').AvatarConfiguration} props
 */
export default function render(props) {
  return renderToStringAsync(NiceAvatar(props));
}
```

and cover it using a quick test

```js
// render/index.spec.mjs
import assert from "node:assert";
import { it } from "node:test";
import render from "./index.mjs";

it("should render the avatar", async () => {
  const svg = await render({});
  assert.ok(svg.startsWith("<svg"));
});
```

## Pushing the monorepo further

Now everything is tested, we're ready to publish our libraries to NPM!

Let's bump every packages to `1.0.0` first using `npm version`:

```sh
npm version major --workspaces --include-workspace-root
@nice-avatar-svg/monorepo
v1.0.0
@nice-avatar-svg/element
v1.0.0
@nice-avatar-svg/preact
v1.0.0
@nice-avatar-svg/react
v1.0.0
@nice-avatar-svg/solid
v1.0.0
@nice-avatar-svg/render
v1.0.0
@nice-avatar-svg/shared
v1.0.0
```

## Conclusion

[react-nice-avatar]: https://github.com/dapi-labs/react-nice-avatar
[web-components]: https://developer.mozilla.org/en-US/docs/Web/API/Web_components
[preact]: https://preactjs.com/
[vite]: https://vitejs.dev/
